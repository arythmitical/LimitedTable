{"searchDocs":[{"title":"Usage Guide","type":0,"sectionRef":"#","url":"/LimitedTable/docs/Usage","content":"","keywords":"","version":"Next"},{"title":"How does it work?​","type":1,"pageTitle":"Usage Guide","url":"/LimitedTable/docs/Usage#how-does-it-work","content":" All changes in LimitedTable are made through custom methods, such as:set(),:insert(), or:remove() — these are the basic operations that the developer usually does with a normal table. (although there are more than 3 methods in the module)  LimitedTable always keeps track of its current size, and only updates it when a change is made. There are no recalculations, only the size of the change is calculated, which allows LimitedTable toerror before actually changing anything and be super fast.  ","version":"Next","tagName":"h2"},{"title":"Syntax​","type":1,"pageTitle":"Usage Guide","url":"/LimitedTable/docs/Usage#syntax","content":" The syntax for LimitedTable is as simple as the syntax for table! Just look:  Creating a table:  local default = {} local limited = LimitedTable.new(1024 * 1000) -- 1MB   Modifying a table:  -- set default.entry = &quot;hi&quot; limited:set(&quot;entry&quot;, &quot;hi&quot;) -- insert table.insert(default, &quot;hi&quot;) limited:insert(&quot;hi&quot;) -- remove table.remove(default, 1) limited:remove(1) -- clear table.clear(default) limited:clear()   Reading a table:  print(default.entry) print(limited.contents.entry) -- just like the default table! -- all functions for reading are also usable with LimitedTable print(table.find(default, &quot;hi&quot;)) print(table.find(limited.contents, &quot;hi&quot;))   ","version":"Next","tagName":"h2"},{"title":"Example​","type":1,"pageTitle":"Usage Guide","url":"/LimitedTable/docs/Usage#example","content":" Check out this example of using LimitedTable! It's a simple code interpreter that uses LimitedTable to limit memory usage of its scripts. ","version":"Next","tagName":"h2"},{"title":"Installation","type":0,"sectionRef":"#","url":"/LimitedTable/docs/Installation","content":"","keywords":"","version":"Next"},{"title":"Option №1 (Wally)​","type":1,"pageTitle":"Installation","url":"/LimitedTable/docs/Installation#option-1-wally","content":" Add LimitedTable to wally.toml dependencies in your project: [dependencies] limitedtable = &quot;arythmitical/limitedtable@2.0.0&quot; Install dependencies using terminal: wally install   ","version":"Next","tagName":"h2"},{"title":"Option №2 (GitHub releases)​","type":1,"pageTitle":"Installation","url":"/LimitedTable/docs/Installation#option-2-github-releases","content":" Get the latest .rbxm (or .luau) file from GitHub releases and insert it into Roblox Studio.  ","version":"Next","tagName":"h2"},{"title":"Option №3 (Creator Marketplace)​","type":1,"pageTitle":"Installation","url":"/LimitedTable/docs/Installation#option-3-creator-marketplace","content":" Creator Marketplace Module ","version":"Next","tagName":"h2"},{"title":"LimitedTable Docs","type":0,"sectionRef":"#","url":"/LimitedTable/docs/intro","content":"LimitedTable Docs Welcome to the documentation of LimitedTable! Here, you'll learn how LimitedTable functions and how to use it. Quick start: InstallationUsage GuideAPI reference","keywords":"","version":"Next"},{"title":"What is Attaching","type":0,"sectionRef":"#","url":"/LimitedTable/docs/What_Is_Attaching","content":"","keywords":"","version":"Next"},{"title":"How it works​","type":1,"pageTitle":"What is Attaching","url":"/LimitedTable/docs/What_Is_Attaching#how-it-works","content":" Let's imagine that you have an environment system and a root table:  local root = LimitedTable.new(1024 * 1000) -- 1MB   To make this 1MB limit span across the entire environment, you need to have all LimitedTables inside of root add to the root's current size, and one of the best ways to solve this is to create an attached LimitedTable:  root:set(&quot;child&quot;, LimitedTable.new(1024 * 1000, { root })) -- now the root will include the child's current size!   Or, you can also attach an existing LimitedTable using:attachTo():  local child = LimitedTable.new(1024 * 1000) child:attachTo(root) root:set(&quot;child&quot;, child)   We've attached table child to table root, and now root includes the size of child, and child is now restricted by both its maximum size and root's maximum size.  You can also attach to multiple LimitedTables:  local child = LimitedTable.new(1024 * 1000, { root, anotherEnv, }) -- or... local child = LimitedTable.new(1024 * 1000) child:attachTo(root) child:attachTo(anotherEnv)   ","version":"Next","tagName":"h2"},{"title":"Detaching​","type":1,"pageTitle":"What is Attaching","url":"/LimitedTable/docs/What_Is_Attaching#detaching","content":" Now, what if the table child is no longer needed? You might have decided to attach it to a different LimitedTable, or you need to get rid of the table child.  In this case, you call :detachFrom():  root:set(&quot;child&quot;, nil) child:detachFrom(root) -- removed from root completely!   If you attached a LimitedTable to multiple LimitedTables, you can call:detachFromAll():  local child = LimitedTable.new(1024 * 1000, { LimitedTable.new(1024 * 1000), LimitedTable.new(1024 * 1000), }) child:detachFromAll()   This method is also called whenever you destroy the LimitedTable:  local child = LimitedTable.new(1024 * 1000, { LimitedTable.new(1024 * 1000), LimitedTable.new(1024 * 1000), }) child:destroy() -- same thing except child is now unusable child = nil   warning LimitedTable does not know if it is used anywhere and when is it going to be garbage collected, thus it can't detach automatically, which can lead to incorrect size calculation. Make sure to call :detachFromAll() or:destroy() on a LimitedTable when it is no longer used. ","version":"Next","tagName":"h2"},{"title":"LimitedTable","type":0,"sectionRef":"#","url":"/LimitedTable/api/LimitedTable","content":"","keywords":"","version":null},{"title":"Properties​","type":1,"pageTitle":"LimitedTable","url":"/LimitedTable/api/LimitedTable#properties","content":" ","version":null,"tagName":"h2"},{"title":"contents​","type":1,"pageTitle":"LimitedTable","url":"/LimitedTable/api/LimitedTable#contents","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; LimitedTable.contents: {[any]: any} Real contents of LimitedTable.  ","version":null,"tagName":"h3"},{"title":"maximumSize​","type":1,"pageTitle":"LimitedTable","url":"/LimitedTable/api/LimitedTable#maximumSize","content":"&lt;/&gt; LimitedTable.maximumSize: number Determines the maximum allowed size of data insideLimitedTable, in bytes. DANGER Reducing the size of this property is dangerous. Make sure the new size is not smaller than LimitedTable._currentSize.  ","version":null,"tagName":"h3"},{"title":"sizeLimitError​","type":1,"pageTitle":"LimitedTable","url":"/LimitedTable/api/LimitedTable#sizeLimitError","content":"&lt;/&gt; LimitedTable.sizeLimitError: string | () → () Determines the error message that will be raised when the maximum size is exceeded. Alternatively, it can be a function that will be invoked instead of raising an error. Default: maximum size of %s bytes exceeded ","version":null,"tagName":"h3"},{"title":"Functions​","type":1,"pageTitle":"LimitedTable","url":"/LimitedTable/api/LimitedTable#functions","content":" ","version":null,"tagName":"h2"},{"title":"new​","type":1,"pageTitle":"LimitedTable","url":"/LimitedTable/api/LimitedTable#new","content":"&lt;/&gt; LimitedTable.new( maximumSize: number, attached: {LimitedTable}?,-- array of attached LimitedTables (default: {}) sizeLimitError: (string | () → ())?-- error message/function (default: &quot;maximum size of %s bytes exceeded&quot;) ) → LimitedTable Construct a new LimitedTable. Example: local lt = LimitedTable.new(1024 * 1000)   ","version":null,"tagName":"h3"},{"title":"convert​","type":1,"pageTitle":"LimitedTable","url":"/LimitedTable/api/LimitedTable#convert","content":"since 2.0.0 &lt;/&gt; LimitedTable.convert( original: {[any]: any},-- the original table to copy maximumSize: number, attached: {LimitedTable}?,-- array of attached LimitedTables (default: {}) sizeLimitError: (string | () → ())?-- error message/function (default: &quot;maximum size of %s bytes exceeded&quot;) ) → LimitedTable Construct a new LimitedTable from a shallow copy of given original table. Example: local lt = LimitedTable.convert({ 1, 2, 3, 4, 5 }, 1024 * 1000) print(lt.contents) --&gt; { 1, 2, 3, 4, 5 }   ","version":null,"tagName":"h3"},{"title":"is​","type":1,"pageTitle":"LimitedTable","url":"/LimitedTable/api/LimitedTable#is","content":"&lt;/&gt; LimitedTable.is(object: any) → boolean Checks if the given object is a LimitedTable created by this libary. Example: print(LimitedTable.is(LimitedTable.new(1024 * 1000))) --&gt; true print(LimitedTable.is({})) --&gt; false   ","version":null,"tagName":"h3"},{"title":"set​","type":1,"pageTitle":"LimitedTable","url":"/LimitedTable/api/LimitedTable#set","content":"&lt;/&gt; LimitedTable.set( self: LimitedTable, key: any, value: any ) → any Sets key of the LimitedTable to value and returns the previous value. Example: local lt = LimitedTable.new(1024 * 1000) lt:set(&quot;a&quot;, &quot;hi&quot;) lt:set(1, &quot;lol&quot;) lt:set(&quot;myArray&quot;, { 1, 2, 3 }) lt:set(&quot;myArray&quot;, LimitedTable.new(1024 * 1000, nil, { lt }))   ","version":null,"tagName":"h3"},{"title":"insert​","type":1,"pageTitle":"LimitedTable","url":"/LimitedTable/api/LimitedTable#insert","content":"&lt;/&gt; LimitedTable.insert( self: LimitedTable, value: any, position: number?-- (default: end of the array) ) → () Inserts value at position of the LimitedTable. Example: local lt = LimitedTable.new(1024 * 1000) for i = 1, 10 do lt:insert(i) end print(lt.contents) --&gt; { 1, 2, 3, ..., 10 }   ","version":null,"tagName":"h3"},{"title":"remove​","type":1,"pageTitle":"LimitedTable","url":"/LimitedTable/api/LimitedTable#remove","content":"&lt;/&gt; LimitedTable.remove( self: LimitedTable, position: number?-- (default: end of the array) ) → () Removes the specified element at given position from LimitedTable, shifting later elements down to fill in the empty space if possible. Returns the removed element. Example: local lt = LimitedTable.new(1024 * 1000) lt:set(&quot;myArray&quot;, { &quot;milk&quot;, &quot;eggs&quot;, &quot;cheese&quot;, }) lt:remove(lt.table.myArray) -- remove last element lt:remove(lt.table.myArray, 1) print(lt.table.myArray) --&gt; { &quot;eggs&quot; }   ","version":null,"tagName":"h3"},{"title":"clear​","type":1,"pageTitle":"LimitedTable","url":"/LimitedTable/api/LimitedTable#clear","content":"since 2.0.0 &lt;/&gt; LimitedTable.clear(self: LimitedTable) → () Sets all keys in the LimitedTable to nil. Example: print(lt.contents) --&gt; { 1, 2, 3, 4, 5 } lt:clear() print(lt.contents) --&gt; {}   ","version":null,"tagName":"h3"},{"title":"attachTo​","type":1,"pageTitle":"LimitedTable","url":"/LimitedTable/api/LimitedTable#attachTo","content":"since 2.0.0 &lt;/&gt; LimitedTable.attachTo( self: LimitedTable, attachTo: LimitedTable-- the LimitedTable to attach to ) → () Tries to attach the LimitedTable to another LimitedTable. If the LimitedTable is already attached, does nothing. DANGER Because attaching a LimitedTable increases the size of the second LimitedTable, this function will error if doing so will exceed second LimitedTable's limits. TIP Always attach an empty LimitedTable or first check the LimitedTable._currentSize of both LimitedTables. Learn more Example: local parent = LimitedTable.new(1024 * 1000) local child = LimitedTable.new(1024 * 1000) child:attachTo(parent) parent:insert(child)   ","version":null,"tagName":"h3"},{"title":"detachFrom​","type":1,"pageTitle":"LimitedTable","url":"/LimitedTable/api/LimitedTable#detachFrom","content":"since 2.0.0 &lt;/&gt; LimitedTable.detachFrom( self: LimitedTable, detachFrom: LimitedTable-- the LimitedTable to detach from ) → () Detaches the LimitedTable from another LimitedTable. If the LimitedTable is not attached, does nothing. NOTE Detaching from a LimitedTable reduces its size. Learn more Example: parent:remove(1) -- removes child child:detachFrom(parent)   ","version":null,"tagName":"h3"},{"title":"detachFromAll​","type":1,"pageTitle":"LimitedTable","url":"/LimitedTable/api/LimitedTable#detachFromAll","content":"since 2.0.0 &lt;/&gt; LimitedTable.detachFromAll(self: LimitedTable) → () Detaches the LimitedTable from all attached LimitedTables. NOTE Detaching from a LimitedTable reduces its size. Learn more Example: child:detachFromAll()   ","version":null,"tagName":"h3"},{"title":"deepCopy​","type":1,"pageTitle":"LimitedTable","url":"/LimitedTable/api/LimitedTable#deepCopy","content":"&lt;/&gt; LimitedTable.deepCopy(self: LimitedTable) → {[any]: any} Returns a deep copy of LimitedTable, with all LimitedTables turned into normal tables and all found metatables removed. TIP If you need a shallow copy, usetable.clone(lt.contents). Example: local lt = LimitedTable.new(1024 * 1000) lt:insert(1) lt:insert(2) lt:insert(3) local raw = lt:deepCopy() print(raw) --&gt; { 1, 2, 3 } print(raw == lt.contents) --&gt; false   ","version":null,"tagName":"h3"},{"title":"destroy​","type":1,"pageTitle":"LimitedTable","url":"/LimitedTable/api/LimitedTable#destroy","content":"&lt;/&gt; LimitedTable.destroy(self: LimitedTable) → () Fully detaches &amp; renders the LimitedTable unusable. WARNING Make sure to delete all references to LimitedTable, otherwise it will stay in the memory forever! Example: local lt = LimitedTable.new(1024 * 1000) local references = setmetatable( { lt, lt.contents }, { __mode = &quot;v&quot; } ) lt:destroy() lt = nil task.wait(8) print(`deleted: {#references == 0}!`) --&gt; true   ","version":null,"tagName":"h3"},{"title":"sizeOf​","type":1,"pageTitle":"LimitedTable","url":"/LimitedTable/api/LimitedTable#sizeOf","content":"&lt;/&gt; LimitedTable.sizeOf(data: any) → number Calculates the size of data. For objects, returns their reference size. This is how LimitedTable calculates sizes. It may not be 100% accurate to the actual memory size but i tried my best. Example: print(LimitedTable.sizeOf(&quot;hi!&quot;)) --&gt; 3 print(LimitedTable.sizeOf({})) --&gt; 40 print(LimitedTable.sizeOf({ 1, 2, 3 })) --&gt; 40  ","version":null,"tagName":"h3"}],"options":{"id":"default"}}