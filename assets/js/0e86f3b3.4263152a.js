"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[732],{9370:e=>{e.exports=JSON.parse('{"functions":[{"name":"new","desc":"Construct a new [LimitedTable](#).\\n\\nExample:\\n```lua\\nlocal lt = LimitedTable.new(512000)\\nend\\n```","params":[{"name":"maximumSize","desc":"","lua_type":"number"},{"name":"attached","desc":"array of attached LimitedTables (default: {})","lua_type":"{ LimitedTable }?"},{"name":"sizeLimitError","desc":"error message/function (default: \\"maximum size of %s bytes exceeded\\")","lua_type":"(string | () -> ())?"}],"returns":[{"desc":"","lua_type":"LimitedTable\\n"}],"function_type":"static","source":{"line":145,"path":"src/init.luau"}},{"name":"is","desc":"Checks if the given `object` is a [LimitedTable](#) created by this libary.\\n\\nExample:\\n```lua\\nprint(LimitedTable.is(LimitedTable.new(512000))) --\x3e true\\nprint(LimitedTable.is({})) --\x3e false\\n```","params":[{"name":"object","desc":"","lua_type":"any"}],"returns":[{"desc":"","lua_type":"boolean\\n"}],"function_type":"static","source":{"line":182,"path":"src/init.luau"}},{"name":"set","desc":"Sets `key` of the [LimitedTable](#) to `value` and returns the previous value.\\n\\nExample:\\n```lua\\nlocal lt = LimitedTable.new(512000)\\n\\nlt:set(\\"a\\", \\"hi\\")\\nlt:set(1, \\"lol\\")\\n\\nlt:set(\\"myArray\\", { 1, 2, 3 })\\n\\nlt:set(\\"myArray\\", LimitedTable.new(512000, nil, { lt }))\\n```","params":[{"name":"self","desc":"","lua_type":"LimitedTable"},{"name":"key","desc":"","lua_type":"any"},{"name":"value","desc":"","lua_type":"any"}],"returns":[{"desc":"","lua_type":"any\\n"}],"function_type":"static","source":{"line":201,"path":"src/init.luau"}},{"name":"insert","desc":"Inserts `value` at `position` of the [LimitedTable](#).\\n\\nExample:\\n```lua\\nlocal lt = LimitedTable.new(512000)\\n\\nfor i = 1, 10 do\\n\\tlt:insert(i)\\nend\\n\\nprint(lt.contents) --\x3e { 1, 2, 3, ..., 10 }\\n```","params":[{"name":"self","desc":"","lua_type":"LimitedTable"},{"name":"value","desc":"","lua_type":"any"},{"name":"position","desc":"(default: end of the array)","lua_type":"number?"}],"returns":[],"function_type":"static","source":{"line":239,"path":"src/init.luau"}},{"name":"remove","desc":"Removes the specified element at given `position` from [LimitedTable](#),\\nshifting later elements down to fill in the empty space if possible.\\nReturns the removed element.\\n\\nExample:\\n```lua\\nlocal lt = LimitedTable.new(512000)\\nlt:set(\\"myArray\\", {\\n\\t\\"milk\\",\\n\\t\\"eggs\\",\\n\\t\\"cheese\\",\\n})\\n\\nlt:remove(lt.table.myArray) -- remove last element\\nlt:remove(lt.table.myArray, 1)\\n\\nprint(lt.table.myArray) --\x3e { \\"eggs\\" }\\n```","params":[{"name":"self","desc":"","lua_type":"LimitedTable"},{"name":"position","desc":"(default: end of the array)","lua_type":"number?"}],"returns":[],"function_type":"static","source":{"line":275,"path":"src/init.luau"}},{"name":"clear","desc":"Sets all keys in the [LimitedTable](#) to nil.","params":[{"name":"self","desc":"","lua_type":"LimitedTable"}],"returns":[],"function_type":"static","source":{"line":298,"path":"src/init.luau"}},{"name":"attachTo","desc":"Tries to attach the [LimitedTable](#) to another LimitedTable.\\nIf the LimitedTable is already attached, does nothing.\\n\\n:::danger\\nBecause attaching a LimitedTable increases the size of the\\nsecond LimitedTable, **this function will error if doing so\\nwill exceed second LimitedTable\'s limits.**\\n:::\\n\\n:::tip\\n**Always** attach an empty LimitedTable or first check the\\n[`LimitedTable._currentSize`](#_currentSize) of _both_ LimitedTables.\\n:::","params":[{"name":"self","desc":"","lua_type":"LimitedTable"},{"name":"attachTo","desc":"the LimitedTable to attach to","lua_type":"LimitedTable"}],"returns":[],"function_type":"static","source":{"line":322,"path":"src/init.luau"}},{"name":"detachFrom","desc":"Detaches the [LimitedTable](#) from another LimitedTable.\\nIf the LimitedTable is not attached, does nothing.\\n\\n:::note\\nDetaching from a LimitedTable reduces its size.\\n:::","params":[{"name":"self","desc":"","lua_type":"LimitedTable"},{"name":"detachFrom","desc":"the LimitedTable to detach from","lua_type":"LimitedTable"}],"returns":[],"function_type":"static","source":{"line":342,"path":"src/init.luau"}},{"name":"detachFromAll","desc":"Detaches the [LimitedTable](#) from all attached LimitedTables.\\n\\n:::note\\nDetaching from a LimitedTable reduces its size.\\n:::","params":[{"name":"self","desc":"","lua_type":"LimitedTable"}],"returns":[],"function_type":"static","source":{"line":362,"path":"src/init.luau"}},{"name":"deepCopy","desc":"Returns a __deep__ copy of [LimitedTable](#),\\nwith all found metatables removed.\\n\\n:::tip\\nIf you need a shallow copy, use\\n[`table.clone(lt.contents)`](https://create.roblox.com/docs/reference/engine/libraries/table#clone).\\n:::\\n\\nExample:\\n```lua\\nlocal lt = LimitedTable.new(512000)\\nlt:insert(1)\\nlt:insert(2)\\nlt:insert(3)\\n\\nlocal raw = lt:cloneRaw()\\nprint(raw) --\x3e { 1, 2, 3 }\\nprint(raw == lt.contents) --\x3e false\\n```","params":[{"name":"self","desc":"","lua_type":"LimitedTable"}],"returns":[{"desc":"","lua_type":"{ [any]: any }\\n"}],"function_type":"static","source":{"line":401,"path":"src/init.luau"}},{"name":"destroy","desc":"Fully [detaches](#detachFromAll) & renders the [LimitedTable](#) unusable.\\n\\n:::warning\\nMake sure to delete _all_ references to LimitedTable,\\notherwise it will stay in the memory forever!\\n:::\\n\\nExample:\\n```lua\\nlocal lt = LimitedTable.new(512000)\\n\\nlocal references = setmetatable(\\n\\t{ lt, lt.contents },\\n\\t{ __mode = \\"v\\" }\\n)\\n\\nlt:destroy()\\nlt = nil\\n\\ntask.wait(8)\\nprint(`deleted: {#references == 0}!`) --\x3e true\\n```","params":[{"name":"self","desc":"","lua_type":"LimitedTable"}],"returns":[],"function_type":"static","source":{"line":431,"path":"src/init.luau"}},{"name":"sizeOf","desc":"Calculates the size of `data`. For objects,\\nreturns their reference size.\\n\\nThis is how [LimitedTable](#) calculates sizes.\\nIt may not be 100% accurate to the actual memory\\nsize but i tried my best.\\n\\nExample:\\n```lua\\nprint(LimitedTable.sizeOf(\\"hi!\\")) --\x3e 3\\nprint(LimitedTable.sizeOf({})) --\x3e 40\\nprint(LimitedTable.sizeOf({ 1, 2, 3 })) --\x3e 40\\n```","params":[{"name":"data","desc":"","lua_type":"any"}],"returns":[{"desc":"","lua_type":"number\\n"}],"function_type":"static","source":{"line":456,"path":"src/init.luau"}}],"properties":[{"name":"contents","desc":"Real contents of [LimitedTable](#).","lua_type":"{ [any]: any }","readonly":true,"source":{"line":23,"path":"src/init.luau"}},{"name":"maximumSize","desc":"Determines the maximum allowed size of data inside\\n[LimitedTable](#), in bytes.\\n\\n:::danger\\nReducing the size of this property is dangerous. Make sure the new\\nsize is not smaller than [`LimitedTable._currentSize`](#_currentSize).\\n:::","lua_type":"number","source":{"line":36,"path":"src/init.luau"}},{"name":"sizeLimitError","desc":"Determines the error message that will be raised when the\\nmaximum size is exceeded. Alternatively, it can be a **function**\\nthat will be invoked instead of raising an error.\\n\\nDefault: `maximum size of %s bytes exceeded`","lua_type":"string | () -> ()","source":{"line":47,"path":"src/init.luau"}},{"name":"_currentSize","desc":"Determines the current size of the data inside the [LimitedTable](#).","lua_type":"number","private":true,"readonly":true,"source":{"line":56,"path":"src/init.luau"}},{"name":"_attached","desc":"Weak internal list of all attached [LimitedTable](#)s, including self.","lua_type":"{ @metatable { __mode: \\"v\\" }, { LimitedTable } }","private":true,"readonly":true,"source":{"line":65,"path":"src/init.luau"}}],"types":[],"name":"LimitedTable","desc":"Table with a total size limit.","source":{"line":13,"path":"src/init.luau"}}')}}]);