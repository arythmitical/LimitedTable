"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[516],{3250:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>c,metadata:()=>i,toc:()=>s});const i=JSON.parse('{"id":"What_Is_Attaching","title":"What is Attaching","description":"LimitedTable has a special feature called attaching, which","source":"@site/docs/What_Is_Attaching.md","sourceDirName":".","slug":"/What_Is_Attaching","permalink":"/LimitedTable/docs/What_Is_Attaching","draft":false,"unlisted":false,"editUrl":"https://github.com/arythmitical/LimitedTable/edit/main/docs/What_Is_Attaching.md","tags":[],"version":"current","frontMatter":{},"sidebar":"defaultSidebar","previous":{"title":"Usage Guide","permalink":"/LimitedTable/docs/Usage"}}');var a=t(4848),l=t(8453);const c={},o="What is Attaching",d={},s=[{value:"How it works",id:"how-it-works",level:2},{value:"Detaching",id:"detaching",level:2}];function r(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",strong:"strong",...(0,l.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"what-is-attaching",children:"What is Attaching"})}),"\n",(0,a.jsxs)(n.p,{children:["LimitedTable has a special feature called ",(0,a.jsx)(n.strong,{children:"attaching"}),", which\nlets you attach a LimitedTable to ",(0,a.jsx)(n.em,{children:"another"})," LimitedTable."]}),"\n",(0,a.jsx)(n.h2,{id:"how-it-works",children:"How it works"}),"\n",(0,a.jsx)(n.p,{children:"Let's imagine that you have an environment system and a root table:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"local root = LimitedTable.new(1024 * 1000) -- 1MB\n"})}),"\n",(0,a.jsxs)(n.p,{children:["To make this 1MB limit span across the entire environment, you need\nto have all LimitedTables inside of ",(0,a.jsx)(n.code,{children:"root"})," add to the ",(0,a.jsx)(n.code,{children:"root"}),"'s current size, and\none of the best ways to solve this is to create an ",(0,a.jsx)(n.em,{children:"attached LimitedTable"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'root:set("child", LimitedTable.new(1024 * 1000, { root }))\n-- now the root will include the child\'s current size!\n'})}),"\n",(0,a.jsxs)(n.p,{children:["Or, you can also attach an existing LimitedTable using\n",(0,a.jsx)(n.a,{href:"../Api#attachTo",children:(0,a.jsx)(n.strong,{children:":attachTo()"})}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'local child = LimitedTable.new(1024 * 1000)\nchild:attachTo(root)\nroot:set("child", child)\n'})}),"\n",(0,a.jsxs)(n.p,{children:["We've attached table ",(0,a.jsx)(n.code,{children:"child"})," to table ",(0,a.jsx)(n.code,{children:"root"}),", and now ",(0,a.jsx)(n.code,{children:"root"})," includes\nthe size of ",(0,a.jsx)(n.code,{children:"child"}),", and ",(0,a.jsx)(n.code,{children:"child"})," is now restricted by both its maximum size\nand ",(0,a.jsx)(n.code,{children:"root"}),"'s maximum size."]}),"\n",(0,a.jsx)(n.p,{children:"You can also attach to multiple LimitedTables:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"local child = LimitedTable.new(1024 * 1000, {\n    root,\n    anotherEnv,\n})\n\n-- or...\nlocal child = LimitedTable.new(1024 * 1000)\nchild:attachTo(root)\nchild:attachTo(anotherEnv)\n"})}),"\n",(0,a.jsx)(n.h2,{id:"detaching",children:"Detaching"}),"\n",(0,a.jsxs)(n.p,{children:["Now, what if the table ",(0,a.jsx)(n.code,{children:"child"})," is no longer needed? You might have decided to\nattach it to a different LimitedTable, or you need to get rid of the table ",(0,a.jsx)(n.code,{children:"child"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["In this case, you call ",(0,a.jsx)(n.a,{href:"../Api#detachFrom",children:(0,a.jsx)(n.strong,{children:":detachFrom()"})}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'root:set("child", nil)\nchild:detachFrom(root) -- removed from root completely!\n'})}),"\n",(0,a.jsxs)(n.p,{children:["If you attached a LimitedTable to multiple LimitedTables, you can call\n",(0,a.jsx)(n.a,{href:"../Api#detachFromAll",children:(0,a.jsx)(n.strong,{children:":detachFromAll()"})}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"local child = LimitedTable.new(1024 * 1000, {\n    LimitedTable.new(1024 * 1000),\n    LimitedTable.new(1024 * 1000),\n})\nchild:detachFromAll()\n"})}),"\n",(0,a.jsxs)(n.p,{children:["This method is also called whenever you ",(0,a.jsx)(n.a,{href:"../Api#destroy",children:"destroy"})," the LimitedTable:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"local child = LimitedTable.new(1024 * 1000, {\n    LimitedTable.new(1024 * 1000),\n    LimitedTable.new(1024 * 1000),\n})\nchild:destroy()\n-- same thing except child is now unusable\nchild = nil\n"})}),"\n",(0,a.jsxs)(n.admonition,{type:"warning",children:[(0,a.jsx)(n.p,{children:"LimitedTable does not know if it is used anywhere and when\nis it going to be garbage collected, thus it can't detach automatically,\nwhich can lead to incorrect size calculation."}),(0,a.jsxs)(n.p,{children:["Make sure to call ",(0,a.jsx)(n.a,{href:"../Api#detachFromAll",children:(0,a.jsx)(n.strong,{children:":detachFromAll()"})})," or\n",(0,a.jsx)(n.a,{href:"../Api#destroy",children:(0,a.jsx)(n.strong,{children:":destroy()"})})," on a LimitedTable when it is no longer used."]})]})]})}function h(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(r,{...e})}):r(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>c,x:()=>o});var i=t(6540);const a={},l=i.createContext(a);function c(e){const n=i.useContext(l);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:c(e.components),i.createElement(l.Provider,{value:n},e.children)}}}]);