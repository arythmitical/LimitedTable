{"searchDocs":[{"title":"LimitedTable","type":0,"sectionRef":"#","url":"/LimitedTable/api/LimitedTable","content":"","keywords":"","version":null},{"title":"Properties​","type":1,"pageTitle":"LimitedTable","url":"/LimitedTable/api/LimitedTable#properties","content":" ","version":null,"tagName":"h2"},{"title":"contents​","type":1,"pageTitle":"LimitedTable","url":"/LimitedTable/api/LimitedTable#contents","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; LimitedTable.contents: {[any]: any} The real contents of LimitedTable.  ","version":null,"tagName":"h3"},{"title":"maximumSize​","type":1,"pageTitle":"LimitedTable","url":"/LimitedTable/api/LimitedTable#maximumSize","content":"&lt;/&gt; LimitedTable.maximumSize: number Determines the maximum allowed size of data insideLimitedTable, in bytes. DANGER Reducing the size of this property is dangerous. Make sure the new size is not smaller than LimitedTable._currentSize.  ","version":null,"tagName":"h3"},{"title":"sizeLimitError​","type":1,"pageTitle":"LimitedTable","url":"/LimitedTable/api/LimitedTable#sizeLimitError","content":"&lt;/&gt; LimitedTable.sizeLimitError: string | () → () Determines the error message that will be raised when the maximum size is exceeded. Alternatively, it can be a function that will be invoked instead of raising an error. Default: maximum size of %s bytes exceeded ","version":null,"tagName":"h3"},{"title":"Functions​","type":1,"pageTitle":"LimitedTable","url":"/LimitedTable/api/LimitedTable#functions","content":" ","version":null,"tagName":"h2"},{"title":"new​","type":1,"pageTitle":"LimitedTable","url":"/LimitedTable/api/LimitedTable#new","content":"&lt;/&gt; LimitedTable.new( maximumSize: number, sizeLimitError: (string | () → ())?,-- error message/function (default: &quot;maximum size of %s bytes exceeded&quot;) attached: {LimitedTable}?-- array of attached LimitedTables (default: {}) ) → LimitedTable Construct a new LimitedTable. Example: local lt = LimitedTable.new(512000) lt.maximumSize += 64000 lt.sizeLimitError = &quot;bum&quot; lt.sizeLimitError = function() game.Players.LocalPlayer:Kick() end   ","version":null,"tagName":"h3"},{"title":"is​","type":1,"pageTitle":"LimitedTable","url":"/LimitedTable/api/LimitedTable#is","content":"&lt;/&gt; LimitedTable.is(object: LimitedTable) → boolean Checks if the given object is a LimitedTable created by this libary. Example: print(LimitedTable.is(LimitedTable.new(512000))) --&gt; true print(LimitedTable.is({})) --&gt; false   ","version":null,"tagName":"h3"},{"title":"set​","type":1,"pageTitle":"LimitedTable","url":"/LimitedTable/api/LimitedTable#set","content":"&lt;/&gt; LimitedTable.set( self: LimitedTable, key: any, value: any ) → () Sets key of the LimitedTable to value. Example: local lt = LimitedTable.new(512000) lt:set(&quot;a&quot;, &quot;hi&quot;) lt:set(1, &quot;lol&quot;) lt:set(&quot;myArray&quot;, { 1, 2, 3 }) lt:set(&quot;myArray&quot;, LimitedTable.new(512000, nil, { lt }))   ","version":null,"tagName":"h3"},{"title":"insert​","type":1,"pageTitle":"LimitedTable","url":"/LimitedTable/api/LimitedTable#insert","content":"&lt;/&gt; LimitedTable.insert( self: LimitedTable, value: any, position: number?-- (default: end of the array) ) → () Inserts value at position of the LimitedTable. Example: local lt = LimitedTable.new(512000) for i = 1, 10 do lt:insert(i) end print(lt.contents) --&gt; { 1, 2, 3, ..., 10 }   ","version":null,"tagName":"h3"},{"title":"remove​","type":1,"pageTitle":"LimitedTable","url":"/LimitedTable/api/LimitedTable#remove","content":"&lt;/&gt; LimitedTable.remove( self: LimitedTable, position: number?-- (default: end of the array) ) → () Removes the specified element at given position from LimitedTable, shifting later elements down to fill in the empty space if possible. Example: local lt = LimitedTable.new(512000) lt:set(&quot;myArray&quot;, { &quot;milk&quot;, &quot;eggs&quot;, &quot;cheese&quot;, }) lt:remove(lt.table.myArray) -- remove last element lt:remove(lt.table.myArray, 1) print(lt.table.myArray) --&gt; { &quot;eggs&quot; }   ","version":null,"tagName":"h3"},{"title":"clear​","type":1,"pageTitle":"LimitedTable","url":"/LimitedTable/api/LimitedTable#clear","content":"&lt;/&gt; LimitedTable.clear(self: LimitedTable) → () Sets all keys in the LimitedTable to nil.  ","version":null,"tagName":"h3"},{"title":"attachTo​","type":1,"pageTitle":"LimitedTable","url":"/LimitedTable/api/LimitedTable#attachTo","content":"&lt;/&gt; LimitedTable.attachTo( self: LimitedTable, attachTo: LimitedTable-- the LimitedTable to attach to ) → () Tries to attach the LimitedTable to another LimitedTable. If the LimitedTable is already attached, does nothing. DANGER Because attaching a LimitedTable increases the size of the second LimitedTable, this function will error if doing so will exceed second LimitedTable's limits. TIP Always attach an empty LimitedTable or first check the LimitedTable._currentSize of both LimitedTables.  ","version":null,"tagName":"h3"},{"title":"detachFrom​","type":1,"pageTitle":"LimitedTable","url":"/LimitedTable/api/LimitedTable#detachFrom","content":"&lt;/&gt; LimitedTable.detachFrom( self: LimitedTable, detachFrom: LimitedTable-- the LimitedTable to detach from ) → () Detaches the LimitedTable from another LimitedTable. If the LimitedTable is not attached, does nothing. NOTE Detaching from a LimitedTable reduces its size.  ","version":null,"tagName":"h3"},{"title":"detachFromAll​","type":1,"pageTitle":"LimitedTable","url":"/LimitedTable/api/LimitedTable#detachFromAll","content":"&lt;/&gt; LimitedTable.detachFromAll(self: LimitedTable) → () Detaches the LimitedTable from all attached LimitedTables. NOTE Detaching from a LimitedTable reduces its size.  ","version":null,"tagName":"h3"},{"title":"deepCopy​","type":1,"pageTitle":"LimitedTable","url":"/LimitedTable/api/LimitedTable#deepCopy","content":"&lt;/&gt; LimitedTable.deepCopy(self: LimitedTable) → {[any]: any} Returns a deep copy of LimitedTable, with all found metatables removed. TIP If you need a shallow copy, use table.clone(lt.contents). Example: local lt = LimitedTable.new(512000) lt:insert(1) lt:insert(2) lt:insert(3) local raw = lt:cloneRaw() print(raw) --&gt; { 1, 2, 3 } print(raw == lt.contents) --&gt; false   ","version":null,"tagName":"h3"},{"title":"destroy​","type":1,"pageTitle":"LimitedTable","url":"/LimitedTable/api/LimitedTable#destroy","content":"&lt;/&gt; LimitedTable.destroy(self: LimitedTable) → () Fully detaches &amp; renders the LimitedTable unusable. WARNING Make sure to delete all references to LimitedTable, otherwise it will stay in the memory forever! Example: local lt = LimitedTable.new(512000) local references = setmetatable( { lt, lt.contents }, { __mode = &quot;v&quot; } ) lt:destroy() lt = nil task.wait(8) print(`deleted: {#references == 0}!`) --&gt; true   ","version":null,"tagName":"h3"},{"title":"sizeOf​","type":1,"pageTitle":"LimitedTable","url":"/LimitedTable/api/LimitedTable#sizeOf","content":"&lt;/&gt; LimitedTable.sizeOf(data: any) → number Calculates the size of data. For objects, returns their reference size. This is how LimitedTable calculates sizes. It may not be 100% accurate to the actual memory size but i tried my best. Example: print(LimitedTable.sizeOf(&quot;hi!&quot;)) --&gt; 3 print(LimitedTable.sizeOf({})) --&gt; 40 print(LimitedTable.sizeOf({ 1, 2, 3 })) --&gt; 40  ","version":null,"tagName":"h3"}],"options":{"id":"default"}}